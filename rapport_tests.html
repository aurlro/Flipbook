<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title id="head-title">rapport_tests.html</title>
      <link href="assets\style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <h1 id="title">rapport_tests.html</h1>
    <p>Report generated on 20-Feb-2025 at 14:59:03 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a>
        v4.1.1</p>
    <div id="environment-header">
      <h2>Environment</h2>
    </div>
    <table id="environment"></table>
    <!-- TEMPLATES -->
      <template id="template_environment_row">
      <tr>
        <td></td>
        <td></td>
      </tr>
    </template>
    <template id="template_results-table__body--empty">
      <tbody class="results-table-row">
        <tr id="not-found-message">
          <td colspan="4">No results found. Check the filters.</th>
        </tr>
    </template>
    <template id="template_results-table__tbody">
      <tbody class="results-table-row">
        <tr class="collapsible">
        </tr>
        <tr class="extras-row">
          <td class="extra" colspan="4">
            <div class="extraHTML"></div>
            <div class="media">
              <div class="media-container">
                  <div class="media-container__nav--left"><</div>
                  <div class="media-container__viewport">
                    <img src="" />
                    <video controls>
                      <source src="" type="video/mp4">
                    </video>
                  </div>
                  <div class="media-container__nav--right">></div>
                </div>
                <div class="media__name"></div>
                <div class="media__counter"></div>
            </div>
            <div class="logwrapper">
              <div class="logexpander"></div>
              <div class="log"></div>
            </div>
          </td>
        </tr>
      </tbody>
    </template>
    <!-- END TEMPLATES -->
    <div class="summary">
      <div class="summary__data">
        <h2>Summary</h2>
        <div class="additional-summary prefix">
        </div>
        <p class="run-count">9 tests took 170 ms.</p>
        <p class="filter">(Un)check the boxes to filter the results.</p>
        <div class="summary__reload">
          <div class="summary__reload__button hidden" onclick="location.reload()">
            <div>There are still tests running. <br />Reload this page to get the latest results!</div>
          </div>
        </div>
        <div class="summary__spacer"></div>
        <div class="controls">
          <div class="filters">
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="failed" />
            <span class="failed">5 Failed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="passed" />
            <span class="passed">4 Passed,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="skipped" disabled/>
            <span class="skipped">0 Skipped,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xfailed" disabled/>
            <span class="xfailed">0 Expected failures,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="xpassed" disabled/>
            <span class="xpassed">0 Unexpected passes,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="error" />
            <span class="error">7 Errors,</span>
            <input checked="true" class="filter" name="filter_checkbox" type="checkbox" data-test-result="rerun" disabled/>
            <span class="rerun">0 Reruns</span>
          </div>
          <div class="collapse">
            <button id="show_all_details">Show all details</button>&nbsp;/&nbsp;<button id="hide_all_details">Hide all details</button>
          </div>
        </div>
      </div>
      <div class="additional-summary summary">
      </div>
      <div class="additional-summary postfix">
      </div>
    </div>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable" data-column-type="result">Result</th>
          <th class="sortable" data-column-type="testId">Test</th>
          <th class="sortable" data-column-type="duration">Duration</th>
          <th>Links</th>
        </tr>
      </thead>
    </table>
  </body>
  <footer>
    <div id="data-container" data-jsonblob="{&#34;environment&#34;: {&#34;Python&#34;: &#34;3.13.2&#34;, &#34;Platform&#34;: &#34;Windows-11-10.0.22631-SP0&#34;, &#34;Packages&#34;: {&#34;pytest&#34;: &#34;8.0.1&#34;, &#34;pluggy&#34;: &#34;1.5.0&#34;}, &#34;Plugins&#34;: {&#34;flask&#34;: &#34;1.3.0&#34;, &#34;html&#34;: &#34;4.1.1&#34;, &#34;metadata&#34;: &#34;3.1.1&#34;}}, &#34;tests&#34;: {&#34;tests/test_html_generator.py::test_generate_html&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_html_generator.py::test_generate_html&#34;, &#34;duration&#34;: &#34;3 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_html_generator.py::test_generate_html&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;3 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_import.py::test_imports&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_import.py::test_imports&#34;, &#34;duration&#34;: &#34;27 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_import.py::test_imports&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;27 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_pdf_processor.py::test_pdf_processing&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_pdf_processor.py::test_pdf_processing::setup&#34;, &#34;duration&#34;: &#34;3 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_pdf_processor.py::test_pdf_processing::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;3 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_pdf_processing&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4D07D910&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_pdf_processor.py::test_invalid_pdf_processing&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_pdf_processor.py::test_invalid_pdf_processing::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_pdf_processor.py::test_invalid_pdf_processing::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_invalid_pdf_processing&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4D04EF10&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_routes.py::test_index_route&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_routes.py::test_index_route::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_routes.py::test_index_route::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_index_route&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4D04FDF0&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_routes.py::test_config_route&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_routes.py::test_config_route::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_routes.py::test_config_route::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_config_route&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4C277950&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_routes.py::test_convert_route&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_routes.py::test_convert_route::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_routes.py::test_convert_route::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_convert_route&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4C284B50&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_routes.py::test_history_route&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_routes.py::test_history_route::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_routes.py::test_history_route::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_history_route&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4D1C9B80&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_routes.py::test_logs_route&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Error&#34;, &#34;testId&#34;: &#34;tests/test_routes.py::test_logs_route::setup&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Error&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_routes.py::test_logs_route::setup&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;request = &amp;lt;SubRequest &amp;#x27;_configure_application&amp;#x27; for &amp;lt;Function test_logs_route&amp;gt;&amp;gt;\nmonkeypatch = &amp;lt;_pytest.monkeypatch.MonkeyPatch object at 0x000001AE4D0532F0&amp;gt;\n\n    @pytest.fixture(autouse=True)\n    def _configure_application(request, monkeypatch):\n        &amp;quot;&amp;quot;&amp;quot;Use `pytest.mark.options` decorator to pass options to your application\n        factory::\n    \n            @pytest.mark.options(debug=False)\n            def test_something(app):\n                assert not app.debug, &amp;#x27;the application works not in debug mode!&amp;#x27;\n    \n        &amp;quot;&amp;quot;&amp;quot;\n        if &amp;quot;app&amp;quot; not in request.fixturenames:\n            return\n    \n&amp;gt;       app = getfixturevalue(request, &amp;quot;app&amp;quot;)\n\nvenv\\Lib\\site-packages\\pytest_flask\\plugin.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\pytest_flask\\pytest_compat.py:3: in getfixturevalue\n    return request.getfixturevalue(value)\ntests\\conftest.py:9: in app\n    app = create_app(&amp;#x27;testing&amp;#x27;)\napp\\__init__.py:6: in create_app\n    app.config.from_object(config_class)\nvenv\\Lib\\site-packages\\flask\\config.py:256: in from_object\n    obj = import_string(obj)\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:611: in import_string\n    raise ImportStringError(import_name, e).with_traceback(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nimport_name = &amp;#x27;testing&amp;#x27;, silent = False\n\n    def import_string(import_name: str, silent: bool = False) -&amp;gt; t.Any:\n        &amp;quot;&amp;quot;&amp;quot;Imports an object based on a string.  This is useful if you want to\n        use import paths as endpoints or something similar.  An import path can\n        be specified either in dotted notation (``xml.sax.saxutils.escape``)\n        or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    \n        If `silent` is True the return value will be `None` if the import fails.\n    \n        :param import_name: the dotted name for the object to import.\n        :param silent: if set to `True` import errors are ignored and\n                       `None` is returned instead.\n        :return: imported object\n        &amp;quot;&amp;quot;&amp;quot;\n        import_name = import_name.replace(&amp;quot;:&amp;quot;, &amp;quot;.&amp;quot;)\n        try:\n            try:\n&amp;gt;               __import__(import_name)\nE               werkzeug.utils.ImportStringError: import_string() failed for &amp;#x27;testing&amp;#x27;. Possible reasons are:\nE               \nE               - missing __init__.py in a package;\nE               - package or module path not included in sys.path;\nE               - duplicated package or module name taking precedence in sys.path;\nE               - missing module, class, function or variable;\nE               \nE               Debugged import:\nE               \nE               - &amp;#x27;testing&amp;#x27; not found.\nE               \nE               Original exception:\nE               \nE               ModuleNotFoundError: No module named &amp;#x27;testing&amp;#x27;\n\nvenv\\Lib\\site-packages\\werkzeug\\utils.py:595: ImportStringError\n&#34;}], &#34;tests/test_setup.py::test_imports&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_setup.py::test_imports&#34;, &#34;duration&#34;: &#34;2 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_setup.py::test_imports&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;2 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_upload.py::test_index_page&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_index_page&#34;, &#34;duration&#34;: &#34;24 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_index_page&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;24 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;FlaskClient &amp;lt;Flask &amp;#x27;app&amp;#x27;&amp;gt;&amp;gt;\n\n    def test_index_page(client):\n&amp;gt;       response = client.get(&amp;#x27;/&amp;#x27;)\n\ntests\\test_upload.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\werkzeug\\test.py:1160: in get\n    return self.open(*args, **kw)\nvenv\\Lib\\site-packages\\flask\\testing.py:235: in open\n    response = super().open(\nvenv\\Lib\\site-packages\\werkzeug\\test.py:1114: in open\n    response = self.run_wsgi_app(request.environ, buffered=buffered)\nvenv\\Lib\\site-packages\\werkzeug\\test.py:986: in run_wsgi_app\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\nvenv\\Lib\\site-packages\\werkzeug\\test.py:1262: in run_wsgi_app\n    app_rv = app(environ, start_response)\nvenv\\Lib\\site-packages\\flask\\app.py:1488: in __call__\n    return self.wsgi_app(environ, start_response)\nvenv\\Lib\\site-packages\\flask\\app.py:1466: in wsgi_app\n    response = self.handle_exception(e)\nvenv\\Lib\\site-packages\\flask\\app.py:1463: in wsgi_app\n    response = self.full_dispatch_request()\nvenv\\Lib\\site-packages\\flask\\app.py:872: in full_dispatch_request\n    rv = self.handle_user_exception(e)\nvenv\\Lib\\site-packages\\flask\\app.py:870: in full_dispatch_request\n    rv = self.dispatch_request()\nvenv\\Lib\\site-packages\\flask\\app.py:855: in dispatch_request\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\napp\\routes\\main.py:21: in index\n    return render_template(&amp;#x27;index.html&amp;#x27;)\nvenv\\Lib\\site-packages\\flask\\templating.py:150: in render_template\n    return _render(app, template, context)\nvenv\\Lib\\site-packages\\flask\\templating.py:131: in _render\n    rv = template.render(context)\nvenv\\Lib\\site-packages\\jinja2\\environment.py:1295: in render\n    self.environment.handle_exception()\nvenv\\Lib\\site-packages\\jinja2\\environment.py:942: in handle_exception\n    raise rewrite_traceback_stack(source=source)\napp\\templates\\index.html:1: in top-level template code\n    {% extends &amp;quot;base.html&amp;quot; %}\napp\\templates\\base.html:51: in top-level template code\n    &amp;lt;a class=&amp;quot;nav-link&amp;quot; href=&amp;quot;{{ url_for(&amp;#x27;config_page&amp;#x27;) }}&amp;quot;&amp;gt;\nvenv\\Lib\\site-packages\\flask\\app.py:1074: in url_for\n    return self.handle_url_build_error(error, endpoint, values)\nvenv\\Lib\\site-packages\\flask\\app.py:1063: in url_for\n    rv = url_adapter.build(  # type: ignore[union-attr]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = &amp;lt;werkzeug.routing.map.MapAdapter object at 0x000001AE4D0C1950&amp;gt;, endpoint = &amp;#x27;config_page&amp;#x27;, values = {}, method = None, force_external = False\nappend_unknown = True, url_scheme = None\n\n    def build(\n        self,\n        endpoint: str,\n        values: t.Mapping[str, t.Any] | None = None,\n        method: str | None = None,\n        force_external: bool = False,\n        append_unknown: bool = True,\n        url_scheme: str | None = None,\n    ) -&amp;gt; str:\n        &amp;quot;&amp;quot;&amp;quot;Building URLs works pretty much the other way round.  Instead of\n        `match` you call `build` and pass it the endpoint and a dict of\n        arguments for the placeholders.\n    \n        The `build` function also accepts an argument called `force_external`\n        which, if you set it to `True` will force external URLs. Per default\n        external URLs (include the server name) will only be used if the\n        target URL is on a different subdomain.\n    \n        &amp;gt;&amp;gt;&amp;gt; m = Map([\n        ...     Rule(&amp;#x27;/&amp;#x27;, endpoint=&amp;#x27;index&amp;#x27;),\n        ...     Rule(&amp;#x27;/downloads/&amp;#x27;, endpoint=&amp;#x27;downloads/index&amp;#x27;),\n        ...     Rule(&amp;#x27;/downloads/&amp;lt;int:id&amp;gt;&amp;#x27;, endpoint=&amp;#x27;downloads/show&amp;#x27;)\n        ... ])\n        &amp;gt;&amp;gt;&amp;gt; urls = m.bind(&amp;quot;example.com&amp;quot;, &amp;quot;/&amp;quot;)\n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;index&amp;quot;, {})\n        &amp;#x27;/&amp;#x27;\n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;downloads/show&amp;quot;, {&amp;#x27;id&amp;#x27;: 42})\n        &amp;#x27;/downloads/42&amp;#x27;\n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;downloads/show&amp;quot;, {&amp;#x27;id&amp;#x27;: 42}, force_external=True)\n        &amp;#x27;http://example.com/downloads/42&amp;#x27;\n    \n        Because URLs cannot contain non ASCII data you will always get\n        bytes back.  Non ASCII characters are urlencoded with the\n        charset defined on the map instance.\n    \n        Additional values are converted to strings and appended to the URL as\n        URL querystring parameters:\n    \n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;index&amp;quot;, {&amp;#x27;q&amp;#x27;: &amp;#x27;My Searchstring&amp;#x27;})\n        &amp;#x27;/?q=My+Searchstring&amp;#x27;\n    \n        When processing those additional values, lists are furthermore\n        interpreted as multiple values (as per\n        :py:class:`werkzeug.datastructures.MultiDict`):\n    \n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;index&amp;quot;, {&amp;#x27;q&amp;#x27;: [&amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;, &amp;#x27;c&amp;#x27;]})\n        &amp;#x27;/?q=a&amp;amp;q=b&amp;amp;q=c&amp;#x27;\n    \n        Passing a ``MultiDict`` will also add multiple values:\n    \n        &amp;gt;&amp;gt;&amp;gt; urls.build(&amp;quot;index&amp;quot;, MultiDict(((&amp;#x27;p&amp;#x27;, &amp;#x27;z&amp;#x27;), (&amp;#x27;q&amp;#x27;, &amp;#x27;a&amp;#x27;), (&amp;#x27;q&amp;#x27;, &amp;#x27;b&amp;#x27;))))\n        &amp;#x27;/?p=z&amp;amp;q=a&amp;amp;q=b&amp;#x27;\n    \n        If a rule does not exist when building a `BuildError` exception is\n        raised.\n    \n        The build method accepts an argument called `method` which allows you\n        to specify the method you want to have an URL built for if you have\n        different methods for the same endpoint specified.\n    \n        :param endpoint: the endpoint of the URL to build.\n        :param values: the values for the URL to build.  Unhandled values are\n                       appended to the URL as query parameters.\n        :param method: the HTTP method for the rule if there are different\n                       URLs for different methods on the same endpoint.\n        :param force_external: enforce full canonical external URLs. If the URL\n                               scheme is not provided, this will generate\n                               a protocol-relative URL.\n        :param append_unknown: unknown parameters are appended to the generated\n                               URL as query string argument.  Disable this\n                               if you want the builder to ignore those.\n        :param url_scheme: Scheme to use in place of the bound\n            :attr:`url_scheme`.\n    \n        .. versionchanged:: 2.0\n            Added the ``url_scheme`` parameter.\n    \n        .. versionadded:: 0.6\n           Added the ``append_unknown`` parameter.\n        &amp;quot;&amp;quot;&amp;quot;\n        self.map.update()\n    \n        if values:\n            if isinstance(values, MultiDict):\n                values = {\n                    k: (v[0] if len(v) == 1 else v)\n                    for k, v in dict.items(values)\n                    if len(v) != 0\n                }\n            else:  # plain dict\n                values = {k: v for k, v in values.items() if v is not None}\n        else:\n            values = {}\n    \n        rv = self._partial_build(endpoint, values, method, append_unknown)\n        if rv is None:\n&amp;gt;           raise BuildError(endpoint, values, method, self)\nE           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint &amp;#x27;config_page&amp;#x27;. Did you mean &amp;#x27;main.config_page&amp;#x27; instead?\n\nvenv\\Lib\\site-packages\\werkzeug\\routing\\map.py:919: BuildError\n&#34;}], &#34;tests/test_upload.py::test_upload_no_file&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_upload_no_file&#34;, &#34;duration&#34;: &#34;5 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_upload_no_file&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;5 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;FlaskClient &amp;lt;Flask &amp;#x27;app&amp;#x27;&amp;gt;&amp;gt;\n\n    def test_upload_no_file(client):\n        response = client.post(&amp;#x27;/&amp;#x27;)\n&amp;gt;       assert b&amp;#x27;Aucun fichier&amp;#x27; in response.data\nE       AssertionError: assert b&amp;#x27;Aucun fichier&amp;#x27; in b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27;\nE        +  where b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27; = &amp;lt;WrapperTestResponse 153 bytes [405 METHOD NOT ALLOWED]&amp;gt;.data\n\ntests\\test_upload.py:39: AssertionError\n&#34;}], &#34;tests/test_upload.py::test_upload_empty_filename&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_upload_empty_filename&#34;, &#34;duration&#34;: &#34;5 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_upload_empty_filename&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;5 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;FlaskClient &amp;lt;Flask &amp;#x27;app&amp;#x27;&amp;gt;&amp;gt;\n\n    def test_upload_empty_filename(client):\n        data = {\n            &amp;#x27;pdf_file&amp;#x27;: (BytesIO(), &amp;#x27;&amp;#x27;)\n        }\n        response = client.post(&amp;#x27;/&amp;#x27;, data=data, content_type=&amp;#x27;multipart/form-data&amp;#x27;)\n&amp;gt;       assert b&amp;#x27;Aucun fichier&amp;#x27; in response.data\nE       AssertionError: assert b&amp;#x27;Aucun fichier&amp;#x27; in b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27;\nE        +  where b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27; = &amp;lt;WrapperTestResponse 153 bytes [405 METHOD NOT ALLOWED]&amp;gt;.data\n\ntests\\test_upload.py:46: AssertionError\n&#34;}], &#34;tests/test_upload.py::test_upload_invalid_extension&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_upload_invalid_extension&#34;, &#34;duration&#34;: &#34;77 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_upload_invalid_extension&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;77 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;FlaskClient &amp;lt;Flask &amp;#x27;app&amp;#x27;&amp;gt;&amp;gt;\n\n    def test_upload_invalid_extension(client):\n        data = {\n            &amp;#x27;pdf_file&amp;#x27;: (BytesIO(b&amp;#x27;not a pdf&amp;#x27;), &amp;#x27;test.txt&amp;#x27;)\n        }\n        response = client.post(&amp;#x27;/&amp;#x27;, data=data, content_type=&amp;#x27;multipart/form-data&amp;#x27;)\n&amp;gt;       assert b&amp;#x27;Type de fichier non autoris&amp;#x27; in response.data\nE       AssertionError: assert b&amp;#x27;Type de fichier non autoris&amp;#x27; in b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27;\nE        +  where b&amp;#x27;&amp;lt;!doctype html&amp;gt;\\n&amp;lt;html lang=en&amp;gt;\\n&amp;lt;title&amp;gt;405 Method Not Allowed&amp;lt;/title&amp;gt;\\n&amp;lt;h1&amp;gt;Method Not Allowed&amp;lt;/h1&amp;gt;\\n&amp;lt;p&amp;gt;The method is not allowed for the requested URL.&amp;lt;/p&amp;gt;\\n&amp;#x27; = &amp;lt;WrapperTestResponse 153 bytes [405 METHOD NOT ALLOWED]&amp;gt;.data\n\ntests\\test_upload.py:53: AssertionError\n&#34;}], &#34;tests/test_upload.py::test_file_validator&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Passed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_file_validator&#34;, &#34;duration&#34;: &#34;1 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Passed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_file_validator&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;1 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;No log output captured.&#34;}], &#34;tests/test_upload.py::test_upload_valid_pdf&#34;: [{&#34;extras&#34;: [], &#34;result&#34;: &#34;Failed&#34;, &#34;testId&#34;: &#34;tests/test_upload.py::test_upload_valid_pdf&#34;, &#34;duration&#34;: &#34;8 ms&#34;, &#34;resultsTableRow&#34;: [&#34;&lt;td class=\&#34;col-result\&#34;&gt;Failed&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-testId\&#34;&gt;tests/test_upload.py::test_upload_valid_pdf&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-duration\&#34;&gt;8 ms&lt;/td&gt;&#34;, &#34;&lt;td class=\&#34;col-links\&#34;&gt;&lt;/td&gt;&#34;], &#34;log&#34;: &#34;client = &amp;lt;FlaskClient &amp;lt;Flask &amp;#x27;app&amp;#x27;&amp;gt;&amp;gt;\n\n    def test_upload_valid_pdf(client):\n        test_pdf = create_test_pdf()\n        data = {\n            &amp;#x27;pdf_file&amp;#x27;: (test_pdf, &amp;#x27;test.pdf&amp;#x27;)\n        }\n        response = client.post(&amp;#x27;/&amp;#x27;, data=data, content_type=&amp;#x27;multipart/form-data&amp;#x27;)\n&amp;gt;       assert response.status_code == 302  # Redirection apr\u00e8s succ\u00e8s\nE       assert 405 == 302\nE        +  where 405 = &amp;lt;WrapperTestResponse streamed [405 METHOD NOT ALLOWED]&amp;gt;.status_code\n\ntests\\test_upload.py:75: AssertionError\n&#34;}]}, &#34;renderCollapsed&#34;: [&#34;passed&#34;], &#34;initialSort&#34;: &#34;result&#34;, &#34;title&#34;: &#34;rapport_tests.html&#34;}"></div>
    <script>
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const { getCollapsedCategory, setCollapsedIds } = require('./storage.js')

class DataManager {
    setManager(data) {
        const collapsedCategories = [...getCollapsedCategory(data.renderCollapsed)]
        const collapsedIds = []
        const tests = Object.values(data.tests).flat().map((test, index) => {
            const collapsed = collapsedCategories.includes(test.result.toLowerCase())
            const id = `test_${index}`
            if (collapsed) {
                collapsedIds.push(id)
            }
            return {
                ...test,
                id,
                collapsed,
            }
        })
        const dataBlob = { ...data, tests }
        this.data = { ...dataBlob }
        this.renderData = { ...dataBlob }
        setCollapsedIds(collapsedIds)
    }

    get allData() {
        return { ...this.data }
    }

    resetRender() {
        this.renderData = { ...this.data }
    }

    setRender(data) {
        this.renderData.tests = [...data]
    }

    toggleCollapsedItem(id) {
        this.renderData.tests = this.renderData.tests.map((test) =>
            test.id === id ? { ...test, collapsed: !test.collapsed } : test,
        )
    }

    set allCollapsed(collapsed) {
        this.renderData = { ...this.renderData, tests: [...this.renderData.tests.map((test) => (
            { ...test, collapsed }
        ))] }
    }

    get testSubset() {
        return [...this.renderData.tests]
    }

    get environment() {
        return this.renderData.environment
    }

    get initialSort() {
        return this.data.initialSort
    }
}

module.exports = {
    manager: new DataManager(),
}

},{"./storage.js":8}],2:[function(require,module,exports){
const mediaViewer = require('./mediaviewer.js')
const templateEnvRow = document.getElementById('template_environment_row')
const templateResult = document.getElementById('template_results-table__tbody')

function htmlToElements(html) {
    const temp = document.createElement('template')
    temp.innerHTML = html
    return temp.content.childNodes
}

const find = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return elem.querySelector(selector)
}

const findAll = (selector, elem) => {
    if (!elem) {
        elem = document
    }
    return [...elem.querySelectorAll(selector)]
}

const dom = {
    getStaticRow: (key, value) => {
        const envRow = templateEnvRow.content.cloneNode(true)
        const isObj = typeof value === 'object' && value !== null
        const values = isObj ? Object.keys(value).map((k) => `${k}: ${value[k]}`) : null

        const valuesElement = htmlToElements(
            values ? `<ul>${values.map((val) => `<li>${val}</li>`).join('')}<ul>` : `<div>${value}</div>`)[0]
        const td = findAll('td', envRow)
        td[0].textContent = key
        td[1].appendChild(valuesElement)

        return envRow
    },
    getResultTBody: ({ testId, id, log, extras, resultsTableRow, tableHtml, result, collapsed }) => {
        const resultBody = templateResult.content.cloneNode(true)
        resultBody.querySelector('tbody').classList.add(result.toLowerCase())
        resultBody.querySelector('tbody').id = testId
        resultBody.querySelector('.collapsible').dataset.id = id

        resultsTableRow.forEach((html) => {
            const t = document.createElement('template')
            t.innerHTML = html
            resultBody.querySelector('.collapsible').appendChild(t.content)
        })

        if (log) {
            // Wrap lines starting with "E" with span.error to color those lines red
            const wrappedLog = log.replace(/^E.*$/gm, (match) => `<span class="error">${match}</span>`)
            resultBody.querySelector('.log').innerHTML = wrappedLog
        } else {
            resultBody.querySelector('.log').remove()
        }

        if (collapsed) {
            resultBody.querySelector('.collapsible > td')?.classList.add('collapsed')
            resultBody.querySelector('.extras-row').classList.add('hidden')
        } else {
            resultBody.querySelector('.collapsible > td')?.classList.remove('collapsed')
        }

        const media = []
        extras?.forEach(({ name, format_type, content }) => {
            if (['image', 'video'].includes(format_type)) {
                media.push({ path: content, name, format_type })
            }

            if (format_type === 'html') {
                resultBody.querySelector('.extraHTML').insertAdjacentHTML('beforeend', `<div>${content}</div>`)
            }
        })
        mediaViewer.setup(resultBody, media)

        // Add custom html from the pytest_html_results_table_html hook
        tableHtml?.forEach((item) => {
            resultBody.querySelector('td[class="extra"]').insertAdjacentHTML('beforeend', item)
        })

        return resultBody
    },
}

module.exports = {
    dom,
    htmlToElements,
    find,
    findAll,
}

},{"./mediaviewer.js":6}],3:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const storageModule = require('./storage.js')

const getFilteredSubSet = (filter) =>
    manager.allData.tests.filter(({ result }) => filter.includes(result.toLowerCase()))

const doInitFilter = () => {
    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)
}

const doFilter = (type, show) => {
    if (show) {
        storageModule.showCategory(type)
    } else {
        storageModule.hideCategory(type)
    }

    const currentFilter = storageModule.getVisible()
    const filteredSubset = getFilteredSubSet(currentFilter)
    manager.setRender(filteredSubset)

    const sortColumn = storageModule.getSort()
    doSort(sortColumn, true)
}

module.exports = {
    doFilter,
    doInitFilter,
}

},{"./datamanager.js":1,"./sort.js":7,"./storage.js":8}],4:[function(require,module,exports){
const { redraw, bindEvents, renderStatic } = require('./main.js')
const { doInitFilter } = require('./filter.js')
const { doInitSort } = require('./sort.js')
const { manager } = require('./datamanager.js')
const data = JSON.parse(document.getElementById('data-container').dataset.jsonblob)

function init() {
    manager.setManager(data)
    doInitFilter()
    doInitSort()
    renderStatic()
    redraw()
    bindEvents()
}

init()

},{"./datamanager.js":1,"./filter.js":3,"./main.js":5,"./sort.js":7}],5:[function(require,module,exports){
const { dom, find, findAll } = require('./dom.js')
const { manager } = require('./datamanager.js')
const { doSort } = require('./sort.js')
const { doFilter } = require('./filter.js')
const {
    getVisible,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    getSortDirection,
    possibleFilters,
} = require('./storage.js')

const removeChildren = (node) => {
    while (node.firstChild) {
        node.removeChild(node.firstChild)
    }
}

const renderStatic = () => {
    const renderEnvironmentTable = () => {
        const environment = manager.environment
        const rows = Object.keys(environment).map((key) => dom.getStaticRow(key, environment[key]))
        const table = document.getElementById('environment')
        removeChildren(table)
        rows.forEach((row) => table.appendChild(row))
    }
    renderEnvironmentTable()
}

const addItemToggleListener = (elem) => {
    elem.addEventListener('click', ({ target }) => {
        const id = target.parentElement.dataset.id
        manager.toggleCollapsedItem(id)

        const collapsedIds = getCollapsedIds()
        if (collapsedIds.includes(id)) {
            const updated = collapsedIds.filter((item) => item !== id)
            setCollapsedIds(updated)
        } else {
            collapsedIds.push(id)
            setCollapsedIds(collapsedIds)
        }
        redraw()
    })
}

const renderContent = (tests) => {
    const sortAttr = getSort(manager.initialSort)
    const sortAsc = JSON.parse(getSortDirection())
    const rows = tests.map(dom.getResultTBody)
    const table = document.getElementById('results-table')
    const tableHeader = document.getElementById('results-table-head')

    const newTable = document.createElement('table')
    newTable.id = 'results-table'

    // remove all sorting classes and set the relevant
    findAll('.sortable', tableHeader).forEach((elem) => elem.classList.remove('asc', 'desc'))
    tableHeader.querySelector(`.sortable[data-column-type="${sortAttr}"]`)?.classList.add(sortAsc ? 'desc' : 'asc')
    newTable.appendChild(tableHeader)

    if (!rows.length) {
        const emptyTable = document.getElementById('template_results-table__body--empty').content.cloneNode(true)
        newTable.appendChild(emptyTable)
    } else {
        rows.forEach((row) => {
            if (!!row) {
                findAll('.collapsible td:not(.col-links', row).forEach(addItemToggleListener)
                find('.logexpander', row).addEventListener('click',
                    (evt) => evt.target.parentNode.classList.toggle('expanded'),
                )
                newTable.appendChild(row)
            }
        })
    }

    table.replaceWith(newTable)
}

const renderDerived = () => {
    const currentFilter = getVisible()
    possibleFilters.forEach((result) => {
        const input = document.querySelector(`input[data-test-result="${result}"]`)
        input.checked = currentFilter.includes(result)
    })
}

const bindEvents = () => {
    const filterColumn = (evt) => {
        const { target: element } = evt
        const { testResult } = element.dataset

        doFilter(testResult, element.checked)
        const collapsedIds = getCollapsedIds()
        const updated = manager.renderData.tests.map((test) => {
            return {
                ...test,
                collapsed: collapsedIds.includes(test.id),
            }
        })
        manager.setRender(updated)
        redraw()
    }

    const header = document.getElementById('environment-header')
    header.addEventListener('click', () => {
        const table = document.getElementById('environment')
        table.classList.toggle('hidden')
        header.classList.toggle('collapsed')
    })

    findAll('input[name="filter_checkbox"]').forEach((elem) => {
        elem.addEventListener('click', filterColumn)
    })

    findAll('.sortable').forEach((elem) => {
        elem.addEventListener('click', (evt) => {
            const { target: element } = evt
            const { columnType } = element.dataset
            doSort(columnType)
            redraw()
        })
    })

    document.getElementById('show_all_details').addEventListener('click', () => {
        manager.allCollapsed = false
        setCollapsedIds([])
        redraw()
    })
    document.getElementById('hide_all_details').addEventListener('click', () => {
        manager.allCollapsed = true
        const allIds = manager.renderData.tests.map((test) => test.id)
        setCollapsedIds(allIds)
        redraw()
    })
}

const redraw = () => {
    const { testSubset } = manager

    renderContent(testSubset)
    renderDerived()
}

module.exports = {
    redraw,
    bindEvents,
    renderStatic,
}

},{"./datamanager.js":1,"./dom.js":2,"./filter.js":3,"./sort.js":7,"./storage.js":8}],6:[function(require,module,exports){
class MediaViewer {
    constructor(assets) {
        this.assets = assets
        this.index = 0
    }

    nextActive() {
        this.index = this.index === this.assets.length - 1 ? 0 : this.index + 1
        return [this.activeFile, this.index]
    }

    prevActive() {
        this.index = this.index === 0 ? this.assets.length - 1 : this.index -1
        return [this.activeFile, this.index]
    }

    get currentIndex() {
        return this.index
    }

    get activeFile() {
        return this.assets[this.index]
    }
}


const setup = (resultBody, assets) => {
    if (!assets.length) {
        resultBody.querySelector('.media').classList.add('hidden')
        return
    }

    const mediaViewer = new MediaViewer(assets)
    const container = resultBody.querySelector('.media-container')
    const leftArrow = resultBody.querySelector('.media-container__nav--left')
    const rightArrow = resultBody.querySelector('.media-container__nav--right')
    const mediaName = resultBody.querySelector('.media__name')
    const counter = resultBody.querySelector('.media__counter')
    const imageEl = resultBody.querySelector('img')
    const sourceEl = resultBody.querySelector('source')
    const videoEl = resultBody.querySelector('video')

    const setImg = (media, index) => {
        if (media?.format_type === 'image') {
            imageEl.src = media.path

            imageEl.classList.remove('hidden')
            videoEl.classList.add('hidden')
        } else if (media?.format_type === 'video') {
            sourceEl.src = media.path

            videoEl.classList.remove('hidden')
            imageEl.classList.add('hidden')
        }

        mediaName.innerText = media?.name
        counter.innerText = `${index + 1} / ${assets.length}`
    }
    setImg(mediaViewer.activeFile, mediaViewer.currentIndex)

    const moveLeft = () => {
        const [media, index] = mediaViewer.prevActive()
        setImg(media, index)
    }
    const doRight = () => {
        const [media, index] = mediaViewer.nextActive()
        setImg(media, index)
    }
    const openImg = () => {
        window.open(mediaViewer.activeFile.path, '_blank')
    }
    if (assets.length === 1) {
        container.classList.add('media-container--fullscreen')
    } else {
        leftArrow.addEventListener('click', moveLeft)
        rightArrow.addEventListener('click', doRight)
    }
    imageEl.addEventListener('click', openImg)
}

module.exports = {
    setup,
}

},{}],7:[function(require,module,exports){
const { manager } = require('./datamanager.js')
const storageModule = require('./storage.js')

const genericSort = (list, key, ascending, customOrder) => {
    let sorted
    if (customOrder) {
        sorted = list.sort((a, b) => {
            const aValue = a.result.toLowerCase()
            const bValue = b.result.toLowerCase()

            const aIndex = customOrder.findIndex((item) => item.toLowerCase() === aValue)
            const bIndex = customOrder.findIndex((item) => item.toLowerCase() === bValue)

            // Compare the indices to determine the sort order
            return aIndex - bIndex
        })
    } else {
        sorted = list.sort((a, b) => a[key] === b[key] ? 0 : a[key] > b[key] ? 1 : -1)
    }

    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const durationSort = (list, ascending) => {
    const parseDuration = (duration) => {
        if (duration.includes(':')) {
            // If it's in the format "HH:mm:ss"
            const [hours, minutes, seconds] = duration.split(':').map(Number)
            return (hours * 3600 + minutes * 60 + seconds) * 1000
        } else {
            // If it's in the format "nnn ms"
            return parseInt(duration)
        }
    }
    const sorted = list.sort((a, b) => parseDuration(a['duration']) - parseDuration(b['duration']))
    if (ascending) {
        sorted.reverse()
    }
    return sorted
}

const doInitSort = () => {
    const type = storageModule.getSort(manager.initialSort)
    const ascending = storageModule.getSortDirection()
    const list = manager.testSubset
    const initialOrder = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed', 'Skipped', 'Passed']

    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    if (type?.toLowerCase() === 'original') {
        manager.setRender(list)
    } else {
        let sortedList
        switch (type) {
        case 'duration':
            sortedList = durationSort(list, ascending)
            break
        case 'result':
            sortedList = genericSort(list, type, ascending, initialOrder)
            break
        default:
            sortedList = genericSort(list, type, ascending)
            break
        }
        manager.setRender(sortedList)
    }
}

const doSort = (type, skipDirection) => {
    const newSortType = storageModule.getSort(manager.initialSort) !== type
    const currentAsc = storageModule.getSortDirection()
    let ascending
    if (skipDirection) {
        ascending = currentAsc
    } else {
        ascending = newSortType ? false : !currentAsc
    }
    storageModule.setSort(type)
    storageModule.setSortDirection(ascending)

    const list = manager.testSubset
    const sortedList = type === 'duration' ? durationSort(list, ascending) : genericSort(list, type, ascending)
    manager.setRender(sortedList)
}

module.exports = {
    doInitSort,
    doSort,
}

},{"./datamanager.js":1,"./storage.js":8}],8:[function(require,module,exports){
const possibleFilters = [
    'passed',
    'skipped',
    'failed',
    'error',
    'xfailed',
    'xpassed',
    'rerun',
]

const getVisible = () => {
    const url = new URL(window.location.href)
    const settings = new URLSearchParams(url.search).get('visible')
    const lower = (item) => {
        const lowerItem = item.toLowerCase()
        if (possibleFilters.includes(lowerItem)) {
            return lowerItem
        }
        return null
    }
    return settings === null ?
        possibleFilters :
        [...new Set(settings?.split(',').map(lower).filter((item) => item))]
}

const hideCategory = (categoryToHide) => {
    const url = new URL(window.location.href)
    const visibleParams = new URLSearchParams(url.search).get('visible')
    const currentVisible = visibleParams ? visibleParams.split(',') : [...possibleFilters]
    const settings = [...new Set(currentVisible)].filter((f) => f !== categoryToHide).join(',')

    url.searchParams.set('visible', settings)
    window.history.pushState({}, null, unescape(url.href))
}

const showCategory = (categoryToShow) => {
    if (typeof window === 'undefined') {
        return
    }
    const url = new URL(window.location.href)
    const currentVisible = new URLSearchParams(url.search).get('visible')?.split(',').filter(Boolean) ||
        [...possibleFilters]
    const settings = [...new Set([categoryToShow, ...currentVisible])]
    const noFilter = possibleFilters.length === settings.length || !settings.length

    noFilter ? url.searchParams.delete('visible') : url.searchParams.set('visible', settings.join(','))
    window.history.pushState({}, null, unescape(url.href))
}

const getSort = (initialSort) => {
    const url = new URL(window.location.href)
    let sort = new URLSearchParams(url.search).get('sort')
    if (!sort) {
        sort = initialSort || 'result'
    }
    return sort
}

const setSort = (type) => {
    const url = new URL(window.location.href)
    url.searchParams.set('sort', type)
    window.history.pushState({}, null, unescape(url.href))
}

const getCollapsedCategory = (renderCollapsed) => {
    let categories
    if (typeof window !== 'undefined') {
        const url = new URL(window.location.href)
        const collapsedItems = new URLSearchParams(url.search).get('collapsed')
        switch (true) {
        case !renderCollapsed && collapsedItems === null:
            categories = ['passed']
            break
        case collapsedItems?.length === 0 || /^["']{2}$/.test(collapsedItems):
            categories = []
            break
        case /^all$/.test(collapsedItems) || collapsedItems === null && /^all$/.test(renderCollapsed):
            categories = [...possibleFilters]
            break
        default:
            categories = collapsedItems?.split(',').map((item) => item.toLowerCase()) || renderCollapsed
            break
        }
    } else {
        categories = []
    }
    return categories
}

const getSortDirection = () => JSON.parse(sessionStorage.getItem('sortAsc')) || false
const setSortDirection = (ascending) => sessionStorage.setItem('sortAsc', ascending)

const getCollapsedIds = () => JSON.parse(sessionStorage.getItem('collapsedIds')) || []
const setCollapsedIds = (list) => sessionStorage.setItem('collapsedIds', JSON.stringify(list))

module.exports = {
    getVisible,
    hideCategory,
    showCategory,
    getCollapsedIds,
    setCollapsedIds,
    getSort,
    setSort,
    getSortDirection,
    setSortDirection,
    getCollapsedCategory,
    possibleFilters,
}

},{}]},{},[4]);
    </script>
  </footer>
</html>